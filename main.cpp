#include <iostream>
#include <string>
#include <stdlib.h>
#include <csignal>
#include <signal.h>


using namespace std;


//Функция, защищающая от ошибок
//при вводе спец.символов (ctrl + c/z/break)
void signalHandler(int signum) {
	cin.clear();
}


int initializeIntegers(string type) {
	//posible args: kingOfGenerate, size, quit, else - compilation error
	/*
	* Функция, задача который - контроль ввода пользователя
	* Аргумент функции - "ключ", позволяющий определить,
	* какую проверку необходимо сделать
	*/
	string inputValue;
	bool isCorrectValue = false;
		while (!isCorrectValue) {
			cin.clear();
			signal(SIGINT, signalHandler);
			signal(SIGBREAK, signalHandler);
			getline(cin, inputValue);
			/*
			* Если передан ключ "size" - функция проверяет корректность
			* ввода размера квадратной матрицы (по условию задачи этот
			* размер должен лежать в отрезке [2;5]
			*/
			if (cin.eof()) {
				cout << "\nВвёденное значение является специальным символом. Введите корректное значение: ";
				continue;
			}
			if (type == "size") {
				if (inputValue.length() != 1 || (inputValue[0] < 50 || inputValue[0] > 53)) {
					cout << "Допустимый ввод: 2, 3, 4, 5.\n";
					cout << "Введённое вами значение не соответсвует допустимому вводу. Пожалуйста, попробуйте еще раз: ";
				}
				else {
					/*
					* Если ввод прошел проверку и является допустимым -
					* булевой переменной присваивается значение true,
					* что позволяет выйти из цикла while
					* для далнейшего выполнения return
					*/
					isCorrectValue = true;
				}
			}
			/*
			* Если передан ключ "kindOfGenerate" - функция проверяет корректность
			* ввода для выбора типа создания массива
			* Допустимый ввод - 1 или 2 (Соответсвие номерам
			* типа создания массива)
			*/
			else if (type == "kindOfGenerate") {
				if (inputValue.length() != 1 || (inputValue[0] < 49 || inputValue[0] > 50)) {
					cout << "Допустимый ввод - 1 или 2.\n";
					cout << "Введённое вами значение не соответсвует допустимому вводу. Пожалуйста, попробуйте еще раз: ";
				}
				else {
					/*
					* Если ввод прошел проверку и является допустимым -
					* булевой переменной, отвечающей за логику,
					* является ли ввод коректным, присваивается
					* значение true
					*/
					isCorrectValue = true;
				}
			}
			/*
			* Если передан ключ "quit" - функция проверяет 
			* введён ли 0 - если да, возврат 0
			* если нет - сообщение о том, что введен не 0
			*/
			else if (type == "quit") {
				if (inputValue == "0") {
					isCorrectValue = true;
				}
				else {
					cout << "Ввёден не 0, ожидаю ввода 0 для завершения: ";
				}
			}
		}
	/*
	* Возвращение значения, введённого пользователем
	* для сохранения в переменную, когда ввод успешно
	* прошел необходимые проверки
	*/
	int stoiInputValue = stoi(inputValue);
	return stoiInputValue;
}


string initializeWords() {
	/*
	* Функция, в которой осуществляется ввод слов
	* для заполнения массива
	* Введенные слова проверяются на условие,
	* поставленное в задаче
	* (длинна слова - 5 символов, только лат.буквы)
	*/
	string inputString;
	bool isCorrectString = false;
	bool isEngLetter;
	while (!isCorrectString) {
		cin.clear();
		signal(SIGINT, signalHandler);
		signal(SIGBREAK, signalHandler);
		getline(cin, inputString);
		isEngLetter = true;
		if (cin.eof()) {
			cout << "\nВвёденное значение является специальным символом. Введите корректное значение: ";
			continue;
		}
		// Проверка на выполнение условия - длинна строки = 5
		if (inputString.length() != 5) {
			cout << "Допустимый размер слова - 5 символов\n";
			cout << "Введённая вами строка не имеет длинну в 5 символов\n";
			cout << "Пожалуйста, введите слово еще раз: ";
		}
		else {
			 /*
			 * Если введённая строка прошла проверку на длинну
			 * Следующей проверкой является проверка на ввод 
			 * только латинских букв.
			 */
			for (int i = 0; i < inputString.length(); i++) {
				/*
				* С помощью цикла проверяется каждый символ в строке
				* В коде ASCII латинские буквы в верхнем регистре
				* лежат в отрезке [65;90], а в нижнем регистре
				* в отрезке [97;122]. Если код очередного символа
				* не принадлежит вышеуказанным отрезкам - пользователя
				* предупреждают о некорректности ввода.
				*/
				if (inputString[i] < 65 ||
					(inputString[i] > 90 && inputString[i] < 97) ||
					inputString[i] > 122) {
					cout << "Введенная вами строка содержит посторонние символы, не принадлежашие англ.алфавиту.\n";
					cout << "Пожалуйста, введите слово еще раз: ";
					/*
					* Если встречен символ не из лат.алфавита -
					* булевой переменной isEngLetter присваивается
					* значение false, для того,чтобы лог.конструкция
					* ниже не выполнилась.
					*/
					isEngLetter = false;
					break;
				}
			}
			/*
			* Условие выхода из цикла while - значение isEngLetter
			* должно быть true.
			*/
			if (isEngLetter) {
				isCorrectString = true;
			}
		}
	}
	/*
	* При успешной проверке введенного пользователем
	* слова, введённая строка возвращается для записи
	* в очередную ячейку массива
	*/
	return inputString;
}


string generateRandomWord() {
	// Функция для случайной генерации слов в матрице
	string generatedString;
	/*
	* Был создан массив из букв латинского алфавите
	* в нижнем и верхнем регистрах.
	*/
	char myAlphabet[52] = { 'a', 'A', 'b', 'B', 'c', 'C', 'd', 'D',
		'e', 'E', 'f', 'F', 'g', 'G', 'h', 'H', 'i', 'I', 'j', 'J',
		'k', 'K', 'l', 'L', 'm', 'M', 'n', 'N', 'o', 'O', 'p', 'P',
		'q', 'Q', 'r', 'R', 's', 'S', 't', 'T', 'u', 'U', 'v', 'V',
		'w', 'W', 'x', 'X', 'y', 'Y', 'z', 'Z' };
	/*
	* При помощи цикла for при каждой итерации
	* с использованием функции rand в конец строковй
	* переменной generatedString добавляется случайно
	* выбранный символ из массива myAlphabet
	*/
	for (int i = 0; i < 5; i++) {
		generatedString += myAlphabet[rand() % 52];
	}
	/*
	* Возвращение сгенерированной строки
	* для записи в очередную ячейку массива
	*/
	return generatedString;
}


string sortString(string unsortedString) {
	/*
	* Эта функция сортирует очередное слово, переданное
	* в качестве аргумента - unsortedString, по англ.алфавиту
	* причем приоритет - нижний регистр. То есть строка
	* "BbAa" будет отсортирована как "aAbB"
	*/
	string sortedString = "";
	char myAlphabet[52] = { 'a', 'A', 'b', 'B', 'c', 'C', 'd', 'D',
		'e', 'E', 'f', 'F', 'g', 'G', 'h', 'H', 'i', 'I', 'j', 'J',
		'k', 'K', 'l', 'L', 'm', 'M', 'n', 'N', 'o', 'O', 'p', 'P',
		'q', 'Q', 'r', 'R', 's', 'S', 't', 'T', 'u', 'U', 'v', 'V',
		'w', 'W', 'x', 'X', 'y', 'Y', 'z', 'Z' };
	/*
	* С помощью конструкции из вложенных циклов сортируется строка:
	* Внешний цикл проходит по каждому элементу в массиве из
	* букв английского алфавита, причем он построен в соответсвии
	* с порядком букв в алфавите. Если при очередном проходе внутреннего цикла 
	* встречена буква, которая является текущей для внешного цикла, то она
	* записывается в конец строковой переменной sortedString.
	*/
	for (size_t i = 0; i < 52; i++){
		for (int j = 0; j < unsortedString.length(); j++) {
			if (unsortedString[j] == myAlphabet[i]) {
				sortedString += myAlphabet[i];
			}
		}
	}
	// Возвращение отсортированной строки.
	return sortedString;
}


bool isVowel(char currentChar) {
	/*
	* Функция с типом bool - проверяет, является ли
	* переданный в качестве аргумента символ гласной буквой
	*/
	char vowels[12] = { 'A', 'a', 'E', 'e', 'I', 'i',
		'O', 'o', 'U', 'u', 'Y', 'y' };
	/*
	* Цикл проходит по каждому элементу массива vowels
	* Этот массив содержит только гласные буквы в верхнем и нижнем регистре
	*/
	for (int i = 0; i < 12; i++){
		//Если буква гласная - функция возвращает true
		if (currentChar == vowels[i]) {
			return true;
		}
	}
	/*
	* Если во время работы цикла не было возвращено значение - 
	* значит переданный в качестве аргумента символ не является
	* гласной буквой. Следовательно можно передать false.
	*/
	return false;
}


void main(){
	srand(time(0)); //Передает функции rand семя, зависящее от текущ.времени.
	setlocale(LC_ALL, "Russian"); //Установка русского языка для консоли.
	cout << "Здравствуйте!\n";
	cout << "__________________________________________________________________________________________________________________________________\n";
	cout << "Данная программа реализует задачу : \n";
	cout << "Создание квадратной матрицы, размер которой пользователь вводит с клавиатуры (допустимый размер - от 2 до 5), и заполнение этой матрицы\n";
	cout << "пятибуквенными английскими \"словами\" (на выбор предлагается 2 вида заполнения - ручной ввод с клавиатуры и случайное заполнение)\n";
	cout << "Далее - каждое слово сортируется в соответствии с алфавитом и отсортированная матрица выводится на экран.\n";
	cout << "Подсчитывается общее количество согласных и гласных букв, результат подсчёта выводится на экран\n";
	cout << "__________________________________________________________________________________________________________________________________\n";
	cout << "Введите размер стороны квадратной матрицы (характеристика М, допустимые значения - целые числа от 2 до 5): ";
	int size = initializeIntegers("size");
	// Создание двумерного массива динамическим путем.
	string** matrix = new string* [size];
	for (int i = 0; i < size; i++) {   
		matrix[i] = new string[size];
	}
	cout << "_______________________________________________________________\n";
	cout << "Каким способом заполнить массив словами?\n";
	cout << "Если вы хотите выбрать способ \"Случайная генерация\" - введите 1\n";
	cout << "Если вы хотите выбрать способ \"Ручной ввод\" - введите 2\n";
	int typeOfGenerate = initializeIntegers("kindOfGenerate");
	if (typeOfGenerate == 1) {
		cout << "_______________________________________________________________\n";
		cout << "Выбран способ заполнения матрицы - Случайная генерация.\n";
	}
	else {
		cout << "_______________________________________________________________\n";
		cout << "Выбран способ заполнения матрицы - Ручной ввод.\n";
		cout << "Введите " << size * size << " слов:\n";
	}
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			if (typeOfGenerate == 1) {
				matrix[i][j] = generateRandomWord();
			}
			else {
				matrix[i][j] = initializeWords();
			}
		}
	}
	//Вывод построенной матрицы в консоль
	cout << "===============================================================\n";
	cout << "Построенная квадратная матрица " << size << "x" << size << endl;
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			cout << matrix[i][j] << "  ";
		}
		cout << endl;
	}
	bool vowelCondition;
	int vowelsCounter = 0, consonantsCounter = 0;
	// Переопределение значений массива в отсортированный вид
	cout << "\n";
	cout << "Отсортированная матрица " << size << "x" << size << endl;
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			matrix[i][j] = sortString(matrix[i][j]);
			for (int k = 0; k < 5; k++) {
				/*
				* Если функиция isVowel вернула true - значит
				* текущая буква в слове гласная - увеличиваем
				* счётчик гласных букв на 1.
				*/
				vowelCondition = isVowel((matrix[i][j])[k]);
				if (vowelCondition) {
					vowelsCounter += 1;
				}
				/*
				* Если функиция вернула false - следовательно
				* текущая буква НЕ гласная, а значит - согласная
				* Увеличение счётчика согл.букв на 1.
				*/
				else {
					consonantsCounter += 1;
				}
			}
			cout << matrix[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
	cout << "Общее число гласных букв в матрице равно " << vowelsCounter << endl
		<< "Общее число согласных букв в матрице равно " << consonantsCounter << endl
		<< "===============================================================\n"
		<< "\nРабота программы окончена.\n"
		<< "Если вы хотите перейти к процессу завершения программы, введите 0: ";
	int inputZero = initializeIntegers("quit");
	while (inputZero != 0) {
		inputZero = initializeIntegers("quit");
	}
	cout << "--- До свидания! ---";
}
